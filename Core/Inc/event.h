/**
 * @file event.h
 * @brief Event queue module for decoupling interrupt handlers from UI processing
 * @author Dennis Rathgeb
 * @date Apr 26, 2024
 *
 * This module implements a linked-list FIFO queue for events generated by
 * button presses and encoder rotation. Events are enqueued in ISR context
 * and dequeued in the main loop for UI processing.
 *
 * @note Uses dynamic memory allocation (malloc/free) which may not be ideal
 *       for real-time embedded systems. Consider using a static memory pool.
 */

#ifndef INC_EVENT_H_
#define INC_EVENT_H_

#include "stm32f0xx_hal.h"
#include "log.h"
#include <stdio.h>
#include <stdlib.h>

/** @brief Enable debug output to UART for event module */
//#define EVENT_ENABLE_LOG

/**
 * @brief Enumeration of all possible event types
 *
 * Events are generated by button presses and encoder rotation.
 */
typedef enum
{
    NO_EVENT = 0,   /**< No event pending */
    BUT1 = 1,       /**< Button 1 pressed (navigate left/down) */
    BUT2 = 2,       /**< Button 2 pressed (navigate right/up) */
    BUT3 = 3,       /**< Button 3 pressed (navigate back) */
    BUT4 = 4,       /**< Button 4 pressed (start/stop) */
    ENC_BUT = 5,    /**< Encoder button pressed (enter/select) */
    ENC_UP = 6,     /**< Encoder rotated clockwise (up/right) */
    ENC_DOWN = 7    /**< Encoder rotated counter-clockwise (down/left) */
} event_type_t;

/**
 * @brief Node structure for the event queue linked list
 */
typedef struct event_node_t {
    event_type_t data;          /**< Event type stored in this node */
    struct event_node_t* next;  /**< Pointer to the next node in queue */
} event_node_t;

/**
 * @brief Handle structure for the event queue
 *
 * Implements a FIFO queue using a singly-linked list with front and rear pointers.
 */
typedef struct {
    event_node_t* front;    /**< Pointer to the front of the queue (dequeue here) */
    event_node_t* rear;     /**< Pointer to the rear of the queue (enqueue here) */
} Event_Queue_HandleTypeDef_t;

/**
 * @brief Initialize the event queue
 * @param[in,out] queue Pointer to queue handle to initialize
 * @return HAL_OK on success, HAL_ERROR if queue is NULL
 */
HAL_StatusTypeDef initEvent(Event_Queue_HandleTypeDef_t* queue);

/**
 * @brief Check if the event queue is empty
 * @param[in] queue Pointer to queue handle
 * @return 1 if queue is empty, 0 if queue has events
 */
uint8_t event_isEmpty(Event_Queue_HandleTypeDef_t* queue);

/**
 * @brief Create a new event node
 * @param[in] data Event type to store in the node
 * @return Pointer to newly allocated node
 * @warning Calls exit() on malloc failure - not recommended for embedded systems
 */
event_node_t* event_createNode(event_type_t data);

/**
 * @brief Add an event to the queue
 * @param[in,out] queue Pointer to queue handle
 * @param[in] event Event type to enqueue
 *
 * This function is typically called from ISR context when a button
 * is pressed or the encoder is rotated.
 */
void event_enqueue(Event_Queue_HandleTypeDef_t* queue, event_type_t event);

/**
 * @brief Remove and return the next event from the queue
 * @param[in,out] queue Pointer to queue handle
 * @return The event type at the front of the queue
 * @warning Calls exit() if queue is empty - check with event_isEmpty() first
 */
event_type_t event_dequeue(Event_Queue_HandleTypeDef_t* queue);

/**
 * @brief Display the contents of the queue (debug function)
 * @param[in] queue Pointer to queue handle
 *
 * Prints all events in the queue to stdout.
 */
void event_displayQueue(Event_Queue_HandleTypeDef_t* queue);

#endif /* INC_EVENT_H_ */
